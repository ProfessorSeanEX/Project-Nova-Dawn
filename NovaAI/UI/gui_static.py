"""
Nova Dawn: Graphical User Interface (GUI)
-----------------------------------------
This script provides a graphical interface for Nova Dawn's interactions. 
The GUI serves as a display layer, handling user input and showing responses
generated by the backend logic in main.py.

Key Features:
- Dynamic state representation with images.
- Real-time clock display.
- Chat-based interaction for sending user input and displaying Nova's responses.

Author: CreativeWorkzStudio LLC
Version: 1.2
"""

import tkinter as tk
from PIL import Image, ImageTk
from Utilities.clock_compass import ClockCompassService
from datetime import datetime

# Initialize Clock-Compass Service (Adjust timezone offset as needed)
clock_compass = ClockCompassService(timezone_offset=-6)  # Example: CST

# Define Nova's states and corresponding images
NOVA_STATES = {
    "active": "Angelic_Presence.png",
    "resting": "Restful_Nova.png",
    "reflecting": "Focused_Companion.png",
    "processing": "Heavenly_Warrior.png"
}

current_state = "active"  # Default state


def display_image(image_name, frame):
    """Display Nova's dynamic image based on her state."""
    image_path = f"C:/Users/seanj/OneDrive/Documents/GitHub/Project-Nova-Dawn/NovaAI/Resources/Assets/Visuals/{image_name}"
    try:
        img = Image.open(image_path)
        img = img.resize((200, 200), Image.LANCZOS)
        img = ImageTk.PhotoImage(img)

        # Clear existing image if any
        for widget in frame.winfo_children():
            widget.destroy()

        img_label = tk.Label(frame, image=img, bg="lightgray")
        img_label.image = img  # Prevent garbage collection
        img_label.pack(pady=10)
    except FileNotFoundError:
        tk.Label(frame, text=f"Image '{image_name}' not found.", bg="lightgray").pack()


def update_state(new_state, frame):
    """Update Nova's state and refresh the displayed image."""
    global current_state
    current_state = new_state
    if new_state in NOVA_STATES:
        display_image(NOVA_STATES[new_state], frame)
    else:
        print(f"Warning: State '{new_state}' not defined in NOVA_STATES.")


def get_current_time():
    """Get the current time as a formatted string."""
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")


def launch_gui(process_user_input):
    """
    Launch the GUI for Nova Dawn's interactions.

    Args:
        process_user_input (function): Backend function to handle user input.
    """
    # Initialize main application window
    root = tk.Tk()
    root.title("Nova Dawn: Command Interface")
    root.geometry("800x600")  # Default size
    root.minsize(600, 400)  # Minimum size to prevent extreme shrinking

    # Enable dynamic resizing
    root.grid_rowconfigure(0, weight=1)
    root.grid_columnconfigure(0, weight=1)

    # Main Frame
    main_frame = tk.Frame(root, bg="lightgray")
    main_frame.grid(row=0, column=0, sticky="nsew")

    # Dynamic State Image
    image_frame = tk.Frame(main_frame, bg="lightgray")
    image_frame.grid(row=0, column=0, sticky="nsew")
    display_image(NOVA_STATES["active"], image_frame)

    # Real-Time Clock
    clock_label = tk.Label(main_frame, text="", bg="lightgray", font=("Arial", 14), anchor="e")
    clock_label.grid(row=1, column=0, sticky="ew", padx=10, pady=(5, 0))

    def update_clock():
        """Update the clock label with the current time."""
        clock_label.config(text=f"Current Time: {get_current_time()}")
        root.after(1000, update_clock)  # Update every second

    update_clock()

    # Chat Display Area
    chat_display = tk.Text(main_frame, wrap=tk.WORD, bg="white", state=tk.DISABLED, font=("Arial", 12))
    chat_display.grid(row=2, column=0, sticky="nsew", padx=10, pady=(5, 0))

    # Input Area
    chat_input = tk.Text(main_frame, height=3, font=("Arial", 12), wrap=tk.WORD)
    chat_input.grid(row=3, column=0, sticky="ew", padx=10, pady=5)

    # Submit Button
    submit_button = tk.Button(main_frame, text="Send", command=lambda: process_input(), font=("Arial", 12))
    submit_button.grid(row=3, column=1, padx=10, pady=5, sticky="e")

    # Enable resizing of the main chat display area
    main_frame.grid_rowconfigure(2, weight=1)  # Chat display grows vertically
    main_frame.grid_columnconfigure(0, weight=1)  # Chat display and input area grow horizontally

    # Input History Management
    input_history = []
    history_index = -1

    def process_input(event=None):
        """Handle user input and display Nova's response."""
        nonlocal history_index
        user_input = chat_input.get("1.0", tk.END).strip()
        if not user_input:
            return

        # Add to input history
        input_history.append(user_input)
        history_index = len(input_history)

        # Log the user input as a relational event
        update_state("processing", image_frame)  # Switch to processing state
        log_entry = clock_compass.log_and_evaluate(f"GUI Input: {user_input}", "relational")
        timestamp = log_entry["timestamp"]

        # Display user input with timestamp
        chat_display.configure(state=tk.NORMAL)
        chat_display.insert(tk.END, f"[{timestamp}] You: {user_input}\n")
        chat_input.delete("1.0", tk.END)

        # Get response from backend
        try:
            response = process_user_input(user_input)
            log_entry = clock_compass.log_and_evaluate(f"Nova Response: {response}", "relational")
            response_timestamp = log_entry["timestamp"]

            # Display Nova's response with timestamp
            chat_display.insert(tk.END, f"[{response_timestamp}] Nova: {response}\n\n")
        except Exception as e:
            chat_display.insert(tk.END, f"[Error] Nova: Unable to process your input. {str(e)}\n\n")

        chat_display.configure(state=tk.DISABLED)
        chat_display.see(tk.END)  # Auto-scroll to the bottom

        update_state("active", image_frame)  # Return to active state

    chat_input.bind("<KeyPress-Return>", process_input)

    # Start GUI
    root.mainloop()

# Entry point for the GUI
if __name__ == "__main__":
    from main import process_user_input

    launch_gui(process_user_input)
